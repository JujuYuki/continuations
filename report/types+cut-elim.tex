%% typing system
%%%% Remove the arrows and move the annotation on the quantifier to gain
%%%% a little space
%% proof that  cut elim maintains typing

\section{Typing decorated terms with MLL}

We first define the language of formulas that we will use for the typing system:
\begin{definition}
The language of formulas is given by the following grammar:
\begin{align*}
A,B::=	&\;\; 1 \;\; | \;\; \bot							& \text{neutrals}\\
%	|	&\;\; u											& u\in N\;\;\;\text{atoms}\\
	|	&\;\; A \logtensor B \;\; | \;\; A \logpar B		& \text{tensor and par}\\
	|	&\;\; \exists_ut.A \;\; | \;\; \forall_ut.A		& t,u\in N\;\;\; \text{existential and universal quantifiers}
\end{align*}
\end{definition}

It is based on the structure of MLL, with atoms formed by the names traded by $\pi$-terms, and first order quantification annotated by those names and quantifying on those names. With that, we give a typing system in the form of deduction rules, of which the first 6 are exactly the rules for MLL if considering only the formulas in the logic part of the rules: 

\begin{definition}
The typing system is given by the following rules, where $\Gamma,\Delta$ are partial functions from $V$ the set of variables to the language of formulas, and where $\Gamma$ and $\Delta$ do not share any variable name when they occur as two hypothesis of the same rule (PARA and CUT):\\~\\
\indent\textbox{
	Rules for neutral elements:\\~\\
	\begin{prooftree}\infer0[NOP]{0_x \vdash x:1}\end{prooftree}\hfill
	\begin{prooftree}\hypo{P \vdash \Gamma\;\;\;\; x\not\in\Gamma}
		\infer1[BOT]{\epsilon_x.P \vdash \Gamma,x:\bot}\end{prooftree}\hfill
	\begin{prooftree}\infer0[AX]{x \tto y \vdash x:E^\bot,y:E}\end{prooftree}\hfill~\\~\\
	Construction rules:\\~\\
	\begin{prooftree}\hypo{P \vdash \Gamma,x:E}
		\hypo{Q \vdash \Delta,x:F}
		\infer2[PARA]{P |_x Q \vdash \Gamma,\Delta,x:E \logtensor F}\end{prooftree}\hfill
	\begin{prooftree}\hypo{P \vdash \Gamma,x:E,y:F}
		\infer1[LAM]{\lambda_xy.P \vdash \Gamma,x:E \logpar F}\end{prooftree}\hfill
	\begin{prooftree}\hypo{P \vdash \Gamma,x:E}
			\hypo{Q \vdash \Delta,x:E^\bot}
		\infer2[CUT]{P||_xQ \vdash \Gamma,\Delta}\end{prooftree}\hfill~\\~\\
	Action rules:\\~\\
	\begin{prooftree}\hypo{P \vdash \Gamma,x:A[v/t]^\bot}
		\infer1[IN]{\bar{u}_x\langle v\rangle.P \vdash \Gamma,x:\exists_u t.A^\bot}\end{prooftree}\hfill
	\begin{prooftree}\hypo{P \vdash \Gamma,x:A\;\;\;t\not\in\Gamma}
		\infer1[OUT]{u_x(t).P \vdash \Gamma,x:\forall_u t.A}\end{prooftree}\hfill~\\~\\
	Nu rule:\\~\\
	\begin{prooftree}\hypo{P \vdash \Gamma\;\;\;\; u\text{ does not appear in any formula of }\Gamma}
		\infer1[NU]{(\nu u)P \vdash \Gamma}\end{prooftree}
}
\end{definition}

One important thing to note here, as explained before, is that for PARA and CUT rules, $\Gamma$ and $\Delta$ are disjoint. The other important thing is that the synchronization construction becomes a CUT operation in the typing system. This rule has elimination transformations, given by the relations $\to$ and $\succ$ defined in \ref{reduction}. Properties we would like to emerge from such a construction would be that the arrows preserve typing, and that their application for cut elimination terminates and actually eliminates cuts.

\begin{proposition}
Relations $\to$ and $\succ$ preserve typing, \ie for all $P\vdash\Gamma$ provable in the typing system and there exists $P'$ such that either $P\to P'$ or $P\succ P'$ can be derived in the reduction system, $P'\vdash\Gamma$ is provable.
\end{proposition}

\begin{myproof}
\textcolor{red}{Show the reduction steps.} %TODO
\end{myproof}

\begin{proposition}
The rewriting system induced by $\to$ and $\succ$ terminates, \ie there is no infinite, strictly decreasing sequence of reductions for this rule.
\end{proposition}

\begin{myproof}
\textcolor{red}{Take all cases in the proof above, and show the strictly decreasing tuple of sizes of terms under the cut. Since $\N$ has no infinite decreasing sequence, by well formed induction, the reduction terminates.} %TODO
\end{myproof}

\remark This system preserves typing and terminates, but does not completely eliminate cut. For example, terms like $u_x(t).\epsilon_y.P ||_y 0_y$ cannot reduce, yet the cut on $y$ is not eliminated. Likewise to the general $\beta$-reduction that can reduce under $\lambda$ in the $\lambda$-calculus, we need to extend relations $\to$ and $\succ$ to be able to reduce under action prefixes, and commute them with cut, as well as extend $\equiv$ to allow commuting action prefixes with other prefixes and parallel as well, when the variables of the operators being commuted do not clash:

\begin{definition}
Relation $\to$ is extended into $\leadsto$ by allowing it to act under action prefixes (no specific rule added).\\~\\
We also extend $\succ$ into $\succsim$ as follows, allowing for it to act on (and under) action prefixes:
\begin{flalign*}
u_x(t).P||_yQ &\succsim u_x(t).(P||_yQ) &\text{symmetric in }||\;\;\;6d\\
\bar{u}_x\langle v \rangle.P||_yQ &\succsim \bar{u}_x\langle v \rangle.(P||_yQ) &\text{symmetric in }||\;\;\;6e
\end{flalign*}
We finally extend $\equiv$ into $\cong$ by allowing $\alpha,\beta$ to be action prefixes in rules $c,d$:
\[\alpha_\cdot,\beta_\cdot \in \{\epsilon_\cdot,\lambda_\cdot z,u_\cdot(t),\bar{u}_\cdot\langle v\rangle\};\]
as well as in rule $f$:
\[\alpha_\cdot \in \{\epsilon_\cdot,\lambda_\cdot z,v_\cdot(t),\bar{v}_\cdot\langle w\rangle, u\neq v, u\neq t,u\neq w\}.\]
\end{definition}

This extension does not match how programs execute in the $\pi$-calculus model, akin to how general $\beta$-reduction does not match the execution of programs in the $\lambda$-calculus model. For example it gives an equivalence between terms $u_x(t).\bar{v}_y\langle w\rangle.P$ and $\bar{v}_y\langle w\rangle.u_x(t).P$, even though they do not behave the same in the projection. However, like the general $\beta$-reduction, it will allow for cut elimination. Also, the way this extension is done, it is immediate by extending the proofs above, since the cases are all treated the same, that:

\begin{corollary}
Relation $\leadsto$ is strongly confluent.
\end{corollary}

\begin{corollary}
The reflexive closure of $\succsim$ is a simulation for $\leadsto$.
\end{corollary}

\begin{corollary}
Relation $\succsim$ is confluent up to $\cong$.
\end{corollary}

\begin{corollary}
For all $P\cong Q$ and $P\leadsto P'$,\\
there exists $Q',Q'',P''$ such that:
\[\begin{tikzcd}
P \arrow[r,phantom,"\cong"]\arrow[d,rightsquigarrow] & Q\arrow[d,phantom,"\dsuccsim^*"]\\
P' \arrow[d,phantom,"\dsuccsim^*"] & Q' \arrow[d,rightsquigarrow]\\
P'' \arrow[r,phantom,"\cong"] & Q''
\end{tikzcd}\]
\end{corollary}

\begin{corollary}
Relations $\leadsto$ and $\succsim$ preserve typing.
\end{corollary}

\begin{corollary}
The rewriting system induced by $\leadsto$ and $\succsim$ terminates
\end{corollary}

Finally, we can prove cut elimination for the extended system:

\begin{proposition}
The reduction system given by rules $\leadsto$ and $\succsim$ eliminates cuts (up to $\cong$),\\
\ie for all $P\vdash\Gamma$ provable in the typing system, there exists $P'$ and a proof of $P\vdash\Gamma$ with $P'\cong P$.
\end{proposition}

\begin{proof}
It is an immediate corollary of the above propositions and extension, as the reduction terminates, preserves typing and now allows cut to be commuted with and reduced under action prefixes.
\end{proof}

\remark With no exponential, it is no surprise that cut elimination terminates.\\

\remark One could also go the way of trying to prove the cut elimination in quantifier-closed context, that is closing the term by cutting successively for all variables of a quantified type against a term with the same variable of an opposite type, so as to end up with a contextualized term which typing does not contain any variable with a quantified type. That lifts the hypothesis of extending the reduction to something that does not match the execution of terms, but the proof also becomes more technical and tedious, and will not be attempted here.

\textcolor{red}{Also, insert here the followed example from the other paper that is to be shown in part 1, to show here that it is not only reducing well, but also well-typed. (Question for later: Is there a term, simplest possible if exists, that reduces well without typing, but cannot be well-typed?)} %TODO