%% syntax + exec of trad \pi-calculus, \equiv
%% projection

\section{Links with the usual $\pi$-calculus}

\begin{definition}
Given a countable set of names $N:=\{t,u,v,\ldots\}$, the grammar defining the terms of the multiplicative $\pi$-calculus is as follows:\\
\begin{flalign*}
P,Q ::=	& 0 \;\; ; \;\; P | Q & \text{null action and parallel construction}\\
		& u(t).P \;\; ; \bar{u}(v).P & \text{sending and receiving names over a channel}\\
		& (\nu u)P & \text{name binding prefix}
\end{flalign*}
We also define a structural congruence on terms as follows:
\begin{align*}
P|0 &\equiv P\\
P|Q &\equiv Q|P\\
P|(Q|R) &\equiv (P|Q)|R\\
(\nu u) P &\equiv P\;\;\;\;\text{if }u\text{ is not a free name in }P
\end{align*}
and a reduction rule:
\[u(t).P|\bar{u}(v)Q \to P[v/t]|Q\]
\end{definition}

We remark most of the important constructions we use in the decorated calculus are here as well, especially being able to specify a name being private, running two processes in parallel as well as send or receive names over a channel. In fact, the synchronization construction from our annotated calculus is a form of parallelization as well, and in a world with no variables to describe the behavior of terms it makes sense to not have a separate construction for that. Also, the $\tto$, $\epsilon$ and $\lambda$ constructions in our annotated system don't do much in the calculus part, aside from allowing to eliminate the synchronization/cut, and their content only affects the typing system. Thus, it makes no sense to have such constructions in a calculus-only system where there is no equivalent to the cut rule from logic systems. We then have covered all constructions from both calculi here, so an interesting thing to do would be to project the annotated calculus that has more constructions in he usual $\pi$-calculus and see it we can get some interesting properties out of that.

\begin{definition}
We define a projection operator $\lfloor\cdot\rfloor$ from the annotated calculus to the above defined $\pi$-calculus as follows:\\
\begin{align*}
\lfloor 0_x \rfloor &= 0 \\
\lfloor x \tto y \rfloor &= 0 \\
\lfloor \lambda_xy.P \rfloor &= \lfloor P \rfloor \\
\lfloor \epsilon_x.P \rfloor &= \lfloor P \rfloor \\
\lfloor u_x(t).P \rfloor &= u(t).\lfloor P \rfloor \\
\lfloor \bar{u}_x\langle v\rangle.P \rfloor &= \bar{u}(v).\lfloor P \rfloor \\
\lfloor P |_x Q \rfloor &= \lfloor P \rfloor | \lfloor Q \rfloor \\
\lfloor P ||_x Q \rfloor &= \lfloor P \rfloor | \lfloor Q \rfloor \\
\lfloor (\nu u)P \rfloor &= (\nu u)\lfloor P \rfloor
\end{align*}
\end{definition}

The important part to verify is that the projection behaves well with the reduction system proposed in part 1:

\begin{proposition}
If $P \to P'$ in the annotated calculus, then $\lfloor P \rfloor \to \lfloor P' \rfloor$ or $\lfloor P \rfloor \equiv \lfloor P' \rfloor$ in usual $\pi$-calculus.\\
If $P \succ P'$ or $P \equiv P'$ in the annotated calculus, then $\lfloor P \rfloor \equiv \lfloor P' \rfloor$ in the usual $\pi$-calculus.
\end{proposition}

\begin{myproof}
\textcolor{red}{Do all meaningful constructions here.\\
In essence: the reduction of $u_x.P||_x\bar{u}_x.Q$ projects to a reduction, everything else projects to structural congruence. Maybe treating this and a few of the structural congruence projections is good, and say that the rest is treated the same way (many similar cases and not really complicated to see, writing everything feels like trying to occupy space just to increase the page count).} %TODO
\end{myproof}

\textcolor{red}{Open about $\leadsto$ here or in the conclusion, because it does not act like a reduction in the projection, but gives some sort of pre-order on terms.} %TODO