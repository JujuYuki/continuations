\documentclass[a4paper,12pt]{book}

\usepackage{mystyle}

\title{Typing a $\pi$-calculus with linear logic}
\author{Julien Gabet}
\date{Mars-June, 2018}

\begin{document}

\everymath{\displaystyle}

\maketitle

\chapter{Elimination of the CUT rule in a simplified system}
We study the following annotated rules for typing simplified $\pi$-calculus with MLL:\\~\\
\indent\textbox{
	Rules for neutral elements:\\~\\
	\begin{prooftree}\infer0{0_x \vdash x:1}\end{prooftree}\hfill
	\begin{prooftree}\hypo{P \vdash \Gamma}
		\infer1{\epsilon_x.P \vdash \Gamma,x:\bot}\end{prooftree}\hfill~\\~\\
	Rules for atoms:\\~\\
	\begin{prooftree}\infer0{A_x \vdash x:a}\end{prooftree}\hfill
	\begin{prooftree}\infer0{x \to y \vdash x:E^\bot,y:E}\end{prooftree}\hfill~\\~\\
	Constructive rules:\\~\\
	\begin{prooftree}\hypo{P \vdash \Gamma,x:E}
		\hypo{Q \vdash \Delta,x:F}
		\infer2{P |_x Q \vdash \Gamma,\Delta,x:E \logtensor F}\end{prooftree}\hfill
	\begin{prooftree}\hypo{P \vdash \Gamma,x:E,y:F}
		\infer1{\lambda_xy.P \vdash \Gamma,x:E \logpar F}\end{prooftree}\hfill~
}\\~\\~\\
And give a translation for the left terms:
\begin{align*}
	\lfloor 0_x \rfloor &= 0 \\
	\lfloor x \to y \rfloor &= 0 \\
	\lfloor A_x \rfloor &= A \\
	\lfloor \epsilon_x.P \rfloor &= P \\
	\lfloor \lambda_xy.P \rfloor &= P \\
	\lfloor P|_xQ \rfloor &= \lfloor P \rfloor | \lfloor Q \rfloor
\end{align*}
Let's introduce a new CUT rule to cut against terms on the right side:
\[\begin{prooftree}\hypo{P \vdash \Gamma,x:E}
	\hypo{Q \vdash \Delta,x:E^\bot}
	\infer2{P||_xQ \vdash \Gamma,\Delta}\end{prooftree}\]
as well as a translation rule for it:
\[ \lfloor P||_xQ \rfloor = \lfloor P \rfloor | \lfloor Q \rfloor \]
\newpage
\begin{proposition}
This CUT rule is admissible in our system, \ie\\
if $P \vdash \Gamma,x:E$ and $Q \vdash \Delta,x:E^\bot$ then there exists $R$ such that $R \vdash \Gamma,\Delta$\\
with $\lfloor R \rfloor = \lfloor P||_xQ \rfloor$, and the proof of $R$ does not use the CUT rule.
\end{proposition}
\begin{myproof}
By induction on the rule we cut against in proof tree:\\
\underline{If one the last rules is not the one that introduced the variable against which we use the CUT rule}, without loss of generality, we can assume this rule was the left rule of the cut (the other case is a perfect symmetry):\\
\underline{Case 1:} the last rule is a tensor rule:
	\begin{itemize}
		\item[i:] the variable was introduced in the left subtree of the last rule
		\[
			\begin{prooftree}
					\hypo{P \vdash \Gamma,x:E}
					\hypo{Q \vdash \Delta,x:F,y:G}
				\infer2{P|_xQ \vdash \Gamma,\Delta,x:E\logtensor F,y:G}
				\hypo{R \vdash \Theta,y:G^\bot}
			\infer2[cut]{(P|_xQ)||_yR \vdash \Gamma,\Delta,\Theta,x:E\logtensor F}
			\end{prooftree}
		\]\[
			\leadsto\;\;\;
			\begin{prooftree}
				\hypo{P \vdash \Gamma,x:E}
					\hypo{Q \vdash \Delta,x:F,y:G}
					\hypo{R \vdash \Theta,y:G^\bot}
				\infer2[cut]{Q||_yR \vdash \Delta,\Theta,x:F}
			\infer2{P|_x(Q||_yR) \vdash \Gamma,\Delta,\Theta,x:E\logtensor F}
			\end{prooftree}
		\]
		And we have the structural congruence\\
		$\lfloor (P|_xQ)||_yR \rfloor = (P|Q)|R \equiv P|(Q|R) = \lfloor P|_x(Q||_yR) \rfloor$.
		\item[ii:] the variable was introduced in the right subtree of the last rule
		\[
			\begin{prooftree}
					\hypo{P \vdash \Gamma,x:E,y:G}
					\hypo{Q \vdash \Delta,x:F}
				\infer2{P|_xQ \vdash \Gamma,\Delta,x:E\logtensor F,y:G}
				\hypo{R \vdash \Theta,y:G^\bot}
			\infer2[cut]{(P|_xQ)||_yR \vdash \Gamma,\Delta,\Theta,x:E\logtensor F}
			\end{prooftree}
		\]\[
			\leadsto\;\;\;
			\begin{prooftree}
					\hypo{P \vdash \Gamma,x:E,y:G}
					\hypo{R \vdash \Theta,y:G^\bot}
				\infer2[cut]{P||_yR \vdash \Gamma,\Theta,x:E}
				\hypo{Q \vdash \Delta,x:F}
			\infer2{(P||_yR)|_xQ \vdash \Gamma,\Delta,\Theta,x:E\logtensor F}
			\end{prooftree}
		\]
		And we have\\
		$\lfloor (P|_xQ)||_yR \rfloor = (P|Q)|R \equiv P|(Q|R) \equiv P|(R|Q) \equiv (P|R)|Q = \lfloor (P||_yR)|_xQ \rfloor$.
	\end{itemize}
\underline{Case 2:} the last rule is not a tensor rule:
	\begin{itemize}
		\item[i:] the last rule is an epsilon rule
		\[
			\begin{prooftree}
					\hypo{P \vdash \Gamma,x:E}
				\infer1{\epsilon_y.P \vdash \Gamma,x:E,y:\bot}
				\hypo{Q \vdash \Delta,x:E^\bot}
			\infer2[cut]{(\epsilon_y.P)||_xQ \vdash \Gamma,\Delta,y:\bot}
			\end{prooftree}
		\]\[
			\leadsto\;\;\;
			\begin{prooftree}
					\hypo{P \vdash \Gamma,x:E}
					\hypo{Q:\Delta,x:E^\bot}
				\infer2[cut]{P||_xQ \vdash \Gamma,\Delta}
			\infer1{\epsilon_y.(P||_xQ) \vdash \Gamma,\Delta,y:\bot}
			\end{prooftree}
		\]
		And we have\\
		$\lfloor (\epsilon_y.P)||_xQ \rfloor = P|Q = \lfloor \epsilon_y.(P||_xQ) \rfloor$
		\item[ii:] the last rule is a lambda rule
		\[
			\begin{prooftree}
					\hypo{P \vdash \Gamma,x:E,y:F,z:G}
				\infer1{\lambda_xy.P \vdash \Gamma,x:E\logpar F,z:G}
				\hypo{Q \vdash \Delta,z:G^\bot}
			\infer2[cut]{(\lambda_xy.P)||_zQ \vdash \Gamma,\Delta,x:E\logpar F}
			\end{prooftree}
		\]\[
			\leadsto\;\;\;
			\begin{prooftree}
					\hypo{P \vdash \Gamma,x:E,y:F,z:G}
					\hypo{Q \vdash \Delta,z:G^\bot}
				\infer2[cut]{P||_zQ \vdash \Gamma,\Delta,x:E,y:F}
			\infer1{\lambda_xy.(P||_zQ) \vdash \Gamma,\Delta,x:E\logpar F}
			\end{prooftree}
		\]
		And we have\\
		$\lfloor (\lambda_xy.P)||_zQ \rfloor = P|Q = \lfloor \lambda_xy.(P||_zQ) \rfloor$
	\end{itemize}
\end{myproof}
\end{document}